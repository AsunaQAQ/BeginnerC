include  表示预处理命令
数据类型
1.基本类型
	整型 字符 浮点（单双精度）枚举
2.构造类型
	数组类型 结构体类型 共用体类型
3.指针类型
4.空类型

%d输出一个十进制数
%c输出一个字符


int 整形 4字节  -32768 ~ 32768
short 短整形 2字节 -32768 ~ 32768
long int 长整形 4字节 -214783648  ~ 214783648
unsigned 无符号型 4字节 0 ~ 65535
unsighed 无符号长整形 4字节 0 ~ 4294967295
float 4字节
double 8字节

C语言的运算符优先级一共15级
1级最高 15级最低
其中分为2种 
1个叫做左结合性
X-Y+Z  Y必须要和X先做减法 再和Z做加法 从左到右依次计算
一个叫做右结合性
X=Y=Z  由于=号的右结合性 必须先执行Y=Z 再执行X=(Y=Z)的运算

&此符号在不同的地方有不同的意义
在scanf语句里，通过在变量x前加一个&符号，我们就可以把输入值存放到变量x的地址中。
	int s;
	scanf_s("%d",&s); //s = 23
	printf("%d\n",s); //输出的是23  是值
	printf("%d", &s); //输出的是地址 1056842054836
	return 0;.

此外有个小问题 如果我将33行代码写为 scanf_s("%d\n",&s); 
则23必须输入2次才有效
百度后得知：
原因是因为scanf（）函数中已经写过了\n,换句话说就是这个函数不需要额外写入\n,scanf()函数与printf（）函数不同，
需要敲击一个回车才能进行读入工作。

问题
输出Sizeof(int)时 按照教程使用%d无法正常输出 百度后使用%zd即可
答：
格式符z和整数转换说明符一起使用，表示对应数字是一个size_t值。属于C99。


定义常量有2种方式
main 函数外 #define  variable
函数主体内   const type  variable;


scanf_s()
此函数用来接收键盘输入参数
原版函数为scanf() 但是由于存在安全隐患 会引用到不存在的元素导致问题发生
从vc++2005开始 vs提供scanf_s() 在调用此函数的同时需要提供一个是数字表明读取多少位字符

实例1：
	float a;
	float b;
	float c;
	scanf_s("%f,%f,%f",&a,&b,&c);
	printf("a:%f  b:%f  c:%f", a, b, c);

	弹出框体内输入 123
	会显示错误数据 这是因为 没有按照scanf_s的格式导致的 
	需要顺序输入1,2,3 （英文格式下）才行
	如果scanf_s中 %f,_%f  2者参数之间存在空格 则必须按照1, 2, 3来输入 需要11对应

实例2：
	double a;
	double b;
	double c;
	scanf_s("%f,%f,%f",&a,&b,&c);
	printf("a:%f  b:%f  c:%f", a, b, c);

	打印结果为错误数字
	scanf_s读%f时，系统会按照4字节长度来读，读完要放到⼀个4字节的空间位置，
	也就是⼀个float所在的位置。那么double有8字节空间，⽐4字节还⼤，能不能来放？
	答案是不能。因为float和double的关系不像int和long的关系那样，简单的在后⾯增加4字节的位置。
	float和double有⾃⼰专门的数据排列格式，如下：如果读的时候明明是按照float的格式
	来读，但是却存在double的空间内，并且之后⼀直按double来操作，那么⾥⾯数据的符号位、
	阶码、尾数就全错位了。除⾮你在⽤的时候把每个double强制转换成float来⽤，但是
	何必多次⼀举？同理，如果读⽤%lf来读，却存在float中，不仅格式错位，⽽且存储空间也不够，
	会有数据丢失。所以⽤scanf_s读的时候，读%f就规规矩矩的放进float中来存，
	读%lf就放进double中，这样在使⽤的时候⾥⾯的数据才不会错位。在printf的时候，
	⾸先C++⾥⾯的float其实在使⽤过程中都是被隐式转换成了double来⽤。所以你在printf时⽤
	float还是double其实是⼀样的。⽤%f和%lf都可以

	所以正确的写法应该是 
	double a,b,c;
	scanf_s("%lf,%lf,%lf",&a,&b,&c)


实例3：
	char a, b, c;

	scanf_s("%c %c %c", &a, 1, &b, 1, &c, 1);

	printf("%c %c %c",a, b, c);

	如果按照 1 2 3输入 则输出的值为 1 2 3
	如果按照 12 23 34 则输出的值为 1 2 3
	这是因为我们在scnaf_s中设置了参数读取的最大位数 都是1 如果超过则掠过




（1）printf的%f说明符既可以输出float型⼜可以输出double型。
	 根据“默认参数提升”规则（在printf这样的函数的可变参数列表中，
	 不论作⽤域内有没有原型，都适⽤这⼀规则）float型会被提升为double型。
	 因此printf()只会看到双精度数。
（2）scanf对于float类型必须⽤%f，double必须⽤%lf
	 对于scanf，情况就完全不同了，它接受指针，这⾥没有类似的类型提升。
	（通过指针）向float存储和向double存储⼤不⼀样，因此，scanf区别%f和%lf。
（3）事实上，printf中没有定义%lf，但是很多系统可能会接受它。要确保可移植性，
	 就要坚持使⽤%f。要想保留⼩数位数，请使⽤(⽐如保留8位⼩数)：
	 printf("%.8f",a)









